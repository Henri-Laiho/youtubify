import urllib.parse
import Levenshtein
import numpy as np
from youtube_search import YoutubeSearch

from src.persistance.storage import Storage, SusCode

BASE_URL = "https://youtube.com"

BLACKLIST = ['live', 'official video', 'official music video', ' at ', 'bass boosted', 'mashup', 'karaoke', 'cover', 'nightcore']


def is_result_autogen(result):
    if 'long_desc' not in result or result['long_desc'] is None:
        return False
    return result['long_desc'].startswith('Provided to YouTube by')


def sigmoid(z):
    return 1 / (1 + np.exp(-z))


def yt_levenshtein(s1, s2, weight_1=1.0):
    sl1, sl2 = s1.lower(), s2.lower()
    lev = Levenshtein.ratio(sl1, sl2) - 0.25
    alnumsplit1 = [''.join(filter(str.isalnum, x)) for x in sl1.split()]
    alnumsplit2 = [''.join(filter(str.isalnum, x)) for x in sl2.split()]
    alnumsplit1 = list(filter(lambda x: len(x) > 0, alnumsplit1))
    alnumsplit2 = list(filter(lambda x: len(x) > 0, alnumsplit2))
    alnum1 = ''.join(filter(str.isalnum, sl1))
    alnum2 = ''.join(filter(str.isalnum, sl2))
    match1 = sum(x in alnum2 for x in alnumsplit1) / max(1, len(alnumsplit1)) * weight_1
    match2 = sum(x in alnum1 for x in alnumsplit2) / max(1, len(alnumsplit2)) * (2 - weight_1)
    if match1 > match2:
        match = match1*1.4 + match2*0.75
    else:
        match = match1*0.75 + match2*1.4
    substr = (alnum1 in alnum2) * weight_1 + (alnum2 in alnum1) * (2 - weight_1)
    return sigmoid((lev + match + substr) * 2 - 3)


def fill0(t):
    return '0' + str(t) if t < 10 else str(t)


def hmsToS(hms):
    s = hms.split(':') if ':' in hms else hms.split('.')
    return ((0 if len(s) < 3 else int(s[-3]) * 3600)
            + (0 if len(s) < 2 else int(s[-2]) * 60)
            + (0 if len(s) < 1 else int(s[-1])))


def get_search_url(search_terms: str):
    encoded_search = urllib.parse.quote(search_terms)
    url = f"{BASE_URL}/results?search_query={encoded_search}"
    return url


def get_search_terms(artists: list, title: str, official=False):
    titler = title.replace('-', '')
    # return ' '.join(['"%s"' % artist for artist in artists]) + f' "Auto-generated by YouTube." "Provided to YouTube by" "{title}"' + (', partner' if official else '')
    return ' '.join(['%s' % artist for artist in artists]) + f' {titler}' + (', partner' if official else '')


def search_track(isrc, artists: list, title: str, duration_s=None, official=False):
    results = YoutubeSearch(get_search_terms(artists, title, official), max_results=400).to_dict()
    for x in results:
        if x['title'] == title and any(
                artist.lower().replace(' ', '') in x['channel'].lower().replace(' ', '') for artist in artists):
            if is_result_autogen(x):
                Storage.set_autogen_track(isrc)
            return BASE_URL + x['url_suffix']
    m_blacklist = [x for x in BLACKLIST if x not in title.lower()]
    titlesplit = ''.join(filter(lambda x: x.isalnum() or x.isspace(), title)).split()
    bestresults = {}
    url_to_result = {}
    for x in results:
        url = BASE_URL + x['url_suffix']
        url_to_result[url] = x
        match = 0
        views = ''.join(filter(str.isnumeric, x['views']))
        if (len(views) > 0 and int(views) > 500
                and (hmsToS(x['duration']) < 900 or duration_s is not None and hmsToS(x['duration']) < duration_s * 2)
                and sum(part in x['title'] for part in titlesplit) > len(titlesplit) // 2
                and sum(artist in x['title'] for artist in artists) > len(artists) // 2
                and all(word not in x['title'].lower() for word in m_blacklist)):
            kws = titlesplit + artists
            match += sum([kw in x['title'] for kw in kws]) - len(x['title'].split()) + (
                0 if duration_s is None else -abs(duration_s - hmsToS(x['duration'])) // 10)
            if match not in bestresults:
                bestresults[match] = []
            bestresults[match].append(url)
    if len(bestresults) > 0:
        url = bestresults[max(bestresults.keys())][0]
        result = url_to_result[url]
        if is_result_autogen(result):
            lev = Levenshtein.ratio(result['title'], title)
            if lev > 0.9:
                Storage.set_autogen_track(isrc)
        return url
    if len(results) == 0:
        return None
    else:
        url = BASE_URL + results[0]['url_suffix']
        Storage.set_sus_track(isrc, url_to_result[url], artists, title, code=SusCode.kws_random_first, data=url)
        return url


def search_isrc_direct(isrc: str, artists: list = None, title: str = None):
    try:
        results = YoutubeSearch('"' + isrc + '"', max_results=3).to_dict()
    except Exception:
        print('Error while searching for track: isrc=%s, artists=%s, title=%s' % (isrc, artists, title))
        Storage.set_sus_track(isrc, search_results=None, artists=artists, title=title, code=SusCode.isrc_error)
        return -1

    alnumartists = None if artists is None else [''.join(filter(str.isalnum, x.lower().replace(' ', ''))) for x in
                                                 artists]
    for x in results:
        alnumchannel = ''.join(filter(str.isalnum, x['channel'].lower().replace(' ', '')))
        lev = 1.0 if title is None else yt_levenshtein(x['title'], title, weight_1=1.1)
        artist_levs = None if artists is None else [yt_levenshtein(artist, alnumchannel) for artist in alnumartists]
        if lev > 0.75 and (artists is None or any(y > 0.65 for y in artist_levs)):
            if lev < 0.9:
                Storage.set_sus_track(isrc, search_results=results, artists=artists, title=title, code=SusCode.isrc_low_lev,
                                      data="lev=%f" % lev)
            elif is_result_autogen(x):
                Storage.set_autogen_track(isrc)
            return BASE_URL + x['url_suffix']
    if len(results) > 0:
        if title is not None and yt_levenshtein(results[0]['title'], title) > 0.75:
            Storage.set_sus_track(isrc, search_results=results, artists=artists, title=title,
                                  code=SusCode.isrc_no_artist_match)
            return BASE_URL + results[0]['url_suffix']
        Storage.set_sus_track(isrc, search_results=results, artists=artists, title=title, code=SusCode.isrc_no_match)
        return -1
    return None


def isrc_search(isrc: str, artists: list, title: str, duration_s=None, official=False, kw_search=True, print_err=False):
    url = search_isrc_direct(isrc, artists=artists, title=title)
    if url is None and kw_search:
        url = search_track(isrc, artists, title, duration_s, official)
        Storage.add_sus_track(isrc, artists=artists, title=title, code=SusCode.kw_search, data=url)
        if print_err:
            print('WARNING: YouTube track not found for', ', '.join(artists), '-', title)
            if url is None:
                print('         No results found for these keywords')
            else:
                print('         Using instead:', url)
    return url

